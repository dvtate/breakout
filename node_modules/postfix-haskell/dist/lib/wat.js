"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WATCode = void 0;
// Not sure if I'll actually end up using this long term...
/**
 * This way we can easily identify where all the expressions originated from
 */
class WATCode {
    constructor() {
        this.parts = [];
        this.sources = [];
    }
    add(s, e) {
        this.parts.push(s);
        this.sources.push(e);
    }
    concat(other) {
        this.parts.push(...other.parts);
        this.sources.push(...other.sources);
    }
}
exports.WATCode = WATCode;
;
/**
 * this is a parametric template string literal
 * @param e - expression source
 */
function wat(e) {
    return (strs, ...bindings) => strs.reduce((a, s, i) => {
        a.add(s, e);
        if (bindings[i - 1])
            a.concat(bindings[i - 1]);
        return a;
    }, new WATCode());
}
exports.default = wat;
;
/* Moved to Type.getWasmTypename
export function watTypename(type : types.Type, name: string = ''): string {
    if (type instanceof types.ClassType)
        type = type.getBaseType();

    if (type instanceof types.PrimitiveType)
        return type.name;

    if (type instanceof types.ArrowType)
        return `(func ${name} (param ${
            type.inputTypes.map(t => watTypename(t)).join(' ')
        }) (result ${
            type.outputTypes.map(t => watTypename(t)).join(' ')
        }))`;

    if (type instanceof types.TupleType)
        return type.types.map(t => watTypename(t)).join(' ');

    if (type instanceof types.UnionType)
        throw new Error("cannot make wat typename for union type");

    // For unit type no typename
    return '';
}
*/ 
//# sourceMappingURL=wat.js.map