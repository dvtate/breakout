"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const macro_1 = require("./macro");
const value = require("./value");
const error = require("./error");
const util_1 = require("../tools/util");
/*
 * These are useful for interactive shell and maybe for compile-time debugging
 *
 * They will not be included in compiled output
 */
/**
 * log output of macro
 * @param name
 * @param ctx
 * @param token
 * @param fn
 */
function logWithToken(name, ctx, token, fn) {
    // This can be improved
    try {
        // Get something to represent
        const repr = fn(ctx, token);
        // Notice that promises are only used for :compile so this is acceptable
        if (repr instanceof Promise)
            repr.then(v => console.log(name, '-', v)).catch(console.error);
        else
            console.log(name, '-', repr);
    }
    catch (e) {
        // Internal vs external error
        if (e instanceof error.CompilerError)
            return e;
        else
            throw e;
    }
}
// Get type name map
const syntaxTypes = Object.entries(value.ValueType)
    .reduce((acc, [k, v]) => ({ ...acc, [v]: k, }), {});
// Some operators for compile time debugging
const debugOperators = {
    // Syntactic type for given value
    ':type': (ctx, token) => {
        // Return debug object with relevant info
        const v = ctx.pop();
        const ret = { syntaxType: syntaxTypes[v.type] };
        if (v.datatype)
            ret.datatype = v.datatype;
        return ret;
    },
    ':ctrace': (ctx, token) => new Error('').stack,
    // Debug context
    ':module': (ctx, token) => ctx.module,
    ':scopes': (ctx, token) => ctx.scopes,
    ':globals': (ctx, token) => ctx.globals,
    ':context': (ctx, token) => ctx,
    // View last item on stack
    ':inspect': (ctx, token) => ctx.pop(),
    ':data': (ctx, token) => {
        const depict = (v) => v.type === value.ValueType.Data
            ? v instanceof value.TupleValue
                ? v.value.map(depict)
                : v instanceof value.NumberValue
                    ? v.value.value
                    : 'unknown'
            : v.value || v;
        return depict(ctx.pop());
    },
    ':eval': (ctx, token) => {
        const str = ctx.pop();
        if (!(str instanceof value.StrValue))
            throw new error.SyntaxError(':eval expected a string containing js code', token, ctx);
        return eval(str.value);
    },
    // View entire stack
    ':stack': (ctx, token) => ctx.stack,
    ':stacklen': (ctx, token) => ctx.stack.length,
    // Prevent compile if value is false
    ':assert': (ctx, token) => {
        const v = ctx.pop();
        if (!(v instanceof value.NumberValue) || !v.value.value)
            throw new error.SyntaxError('Assertion failed', token, ctx);
        return 'pass';
    },
    // Prevent compilation
    ':error': (ctx, token) => {
        const msg = ctx.pop();
        if (!(msg instanceof value.StrValue))
            throw new error.SyntaxError(':error expected a string message', token, ctx);
        throw new error.SyntaxError(`:error - ${msg.value}`, token, ctx);
    },
    // Debug the semantics stack trace
    ':locate': (ctx, token) => {
        const v = ctx.pop();
        return (0, util_1.formatErrorPos)([{ name: token.token, message: token.token, tokens: [v.token] }]);
    },
    // Compilation and stuff
    ':targets': (ctx, token) => ctx.exports,
    ':compile': async (ctx, token) => await ctx.outWast({}),
    ':wast': async (ctx, token) => await ctx.outWast({ folding: true }),
    ':wat': async (ctx, token) => await ctx.outWast({ folding: false }),
};
// Export Macros because user shouldn't override
exports.default = Object.entries(debugOperators).reduce((acc, [k, v]) => ({
    ...acc,
    [k]: new value.MacroValue(undefined, new macro_1.CompilerMacro((ctx, token) => logWithToken(k, ctx, token, v))),
}), {});
//# sourceMappingURL=debug_macros.js.map