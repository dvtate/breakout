"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrowType = exports.PrimitiveType = exports.TupleType = exports.UnionType = exports.ClassType = exports.AnyType = exports.Type = void 0;
/**
 * Abstract base for datatypes
 */
class Type {
    /**
     * @param {LexerToken} [token] -
     */
    constructor(token = undefined) {
        this.token = token;
    }
    /**
     * Gives type that class refers to
     * @returns {Type} - Underlying datatype
     * @virtual
     */
    getBaseType() { return this; }
    /**
     * Gives the wasm typename for given type
     * @returns {sting} - typename
     * @virtual
     */
    getWasmTypeName(name) { return ''; }
    /**
     * Get a flat list of primitive types that constitute this type
     * @returns list of primitives that this type compiles to
     * @throws if union encountered throws string "union"
     */
    flatPrimitiveList() {
        return [];
    }
    /**
     * Does this type hold a value in wasm?
     * @virtual
     */
    isVoid() {
        return false;
    }
    /**
     * Do Typecheck
     * @param {Type} type - type to check against
     * @virtual
     */
    check(type) {
        // Default behavior is to act as a wildcard
        return type != null;
    }
}
exports.Type = Type;
;
/**
 * Type which matches any other type
 */
class AnyType extends Type {
}
exports.AnyType = AnyType;
;
/**
 * More specific than types, used for applying methods and stuff
 */
class ClassType extends Type {
    /**
     * @param token - code where
     * @param type - Underlying Data type
     * @param [id] - Clone a class
     */
    constructor(token, type, id = ClassType._uid++) {
        super(token);
        this.type = type;
        this.id = id;
    }
    /**
     * @override
     */
    check(type) {
        if (type === null)
            return false;
        // Check class
        if (type instanceof ClassType) {
            // Check compatible class
            const otherClasses = type.getClassIds();
            const classMatch = this.getClassIds().some(id => otherClasses.includes(id));
            // console.log('classmatch: ', classMatch);
            if (!classMatch)
                return false;
            // Check data schema
            if (!this.type)
                return true;
            return this.getBaseType().check(type);
        }
        // Expected a class
        return false;
    }
    /**
     * @override
     */
    getBaseType() {
        let ret = this.type;
        while (ret instanceof ClassType)
            ret = ret.type;
        return ret;
    }
    /**
     * @override
     */
    flatPrimitiveList() {
        return this.getBaseType().flatPrimitiveList();
    }
    /**
     * @override
     */
    getWasmTypeName(name) {
        return this.getBaseType().getWasmTypeName(name);
    }
    /**
     * @returns {Number[]} - list of class ids for this type
     */
    getClassIds() {
        const ret = [this.id];
        let type = this.type;
        while (type instanceof ClassType) {
            ret.push(type.id);
            type = type.type;
        }
        return ret;
    }
    /**
     * @override
     */
    isVoid() {
        return this.getBaseType().isVoid();
    }
}
exports.ClassType = ClassType;
ClassType._uid = 0;
;
/**
 * When need to be able to handle more than one type
 *  aka sum type (`|`)
 */
class UnionType extends Type {
    constructor(token = undefined, types = []) {
        super(token);
        this.types = types;
    }
    /**
     * @override
     */
    check(type) {
        if (type === null)
            return false;
        // Don't care about classes
        if (type instanceof ClassType) {
            type = type.getBaseType();
            if (!type)
                return false;
        }
        // Verify other union is subset of this one
        if (type instanceof UnionType)
            return type.types.every(t => this.types.includes(t));
        // Verify type is in this set
        return this.types.includes(type);
    }
    /**
     * @override
     */
    flatPrimitiveList() {
        throw "union type";
    }
    /**
     * @override
     */
    getWasmTypeName(name) {
        return 'invalid union type';
    }
}
exports.UnionType = UnionType;
;
/**
 * When need to store more than one piece of data in a single value
 *  aka product type (`pack`)
 */
class TupleType extends Type {
    constructor(token = undefined, types = []) {
        super(token);
        this.types = types;
    }
    /**
     * @override
     */
    getWasmTypeName(name) {
        return this.types.map(t => t.getWasmTypeName(name)).join(' ');
    }
    /**
     * @override
     */
    isVoid() {
        return this.types.length === 0;
    }
    /**
     * @override
     */
    flatPrimitiveList() {
        return this.types
            .map(t => t.flatPrimitiveList())
            .reduce((a, b) => a.concat(b));
    }
    /**
     * @override
     */
    check(type) {
        if (type == null)
            return false;
        // Don't care about classes
        if (type instanceof ClassType) {
            type = type.getBaseType();
            if (!type)
                return false;
        }
        // Not a tuple
        if (!(type instanceof TupleType))
            return false;
        // Different size
        if (this.types.length !== type.types.length)
            return false;
        // Verify types match
        for (let i = 0; i < this.types.length; i++)
            if (!this.types[i].check(type.types[i]))
                return false;
        return true;
    }
}
exports.TupleType = TupleType;
;
/**
 * Type that's a component of compilation target
 */
class PrimitiveType extends Type {
    /**
     * @param {String} name - formal name for type in target spec
     */
    constructor(name) {
        super();
        this.name = name;
    }
    /**
     * @override
     */
    getWasmTypeName(name) {
        return this.name;
    }
    /**
     * @override
     */
    check(type) {
        if (type == null)
            return false;
        // Don't care about classes
        if (type instanceof ClassType) {
            type = type.getBaseType();
            if (!type)
                return false;
        }
        // All instances of PrimitiveType will be in the static Types map
        return this == type;
    }
    /**
     * @override
     */
    flatPrimitiveList() {
        return [this];
    }
}
exports.PrimitiveType = PrimitiveType;
// Map of WASM primitive types
PrimitiveType.Types = {
    I32: new PrimitiveType('i32'),
    I64: new PrimitiveType('i64'),
    F32: new PrimitiveType('f32'),
    F64: new PrimitiveType('f64'),
};
;
/**
 * Datatype to describe function/macros
 */
class ArrowType extends Type {
    constructor(token, inputTypes, outputTypes) {
        super(token);
        this.inputTypes = inputTypes;
        this.outputTypes = outputTypes;
    }
    /**
     * @override
     */
    getWasmTypeName(name) {
        return `(func ${name} (param ${this.inputTypes.map(t => t.getWasmTypeName()).join(' ')}) (result ${this.outputTypes.map(t => t.getWasmTypeName()).join(' ')}))`;
    }
    /**
     * @override
     */
    check(type) {
        if (!(type instanceof ArrowType))
            return false;
        return !(this.inputTypes.some((t, i) => t.check(type.inputTypes[i]))
            || this.outputTypes.some((t, i) => t.check(type.outputTypes[i])));
    }
}
exports.ArrowType = ArrowType;
;
// TODO add ValueTypes as classes?
//# sourceMappingURL=datatypes.js.map