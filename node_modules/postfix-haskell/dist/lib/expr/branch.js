"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchExpr = void 0;
const types = require("../datatypes");
const error = require("../error");
const expr_1 = require("./expr");
/**
 * Describes branching action
 *
 * this should only get used when it cannot be determined which branch to take at compile time
 */
class BranchExpr extends expr_1.Expr {
    /**
     * @param token - location in code
     * @param conditions - conditions for branches
     * @param actions - actions for brances
     */
    constructor(tokens, conditions, actions, name) {
        super(tokens[0]);
        this.name = name;
        this.tokens = tokens;
        this.conditions = (0, expr_1.fromDataValue)(conditions);
        this.actions = actions.map(expr_1.fromDataValue);
        this.results = [];
    }
    /**
     * @override
     */
    out(ctx, fun) {
        // Prevent multiple compilations
        this._isCompiled = true;
        // Compile body
        // Notice order of compilation from top to bottom so that locals are assigned before use
        const conds = new Array(this.conditions.length);
        const acts = new Array(this.actions.length);
        for (let i = this.conditions.length - 1; i >= 0; i--) {
            const invIdx = (this.conditions.length - i) - 1;
            conds[invIdx] = this.conditions[i].out(ctx, fun);
            acts[invIdx] = this.actions[i].reverse().map(a => a.out(ctx, fun)).join(' ');
        }
        // const conds = this.conditions.map(c => c.out(ctx, fun)).reverse();
        // const acts = this.actions.map(a => a.map(v => v.out(ctx, fun)).join(' ')).reverse();
        // Generate result type signature
        const retType = this.actions[0].map(e => e.datatype.getWasmTypeName()).join(' ');
        // Set up dependent locals
        const results = this.results.filter(r => !r.datatype.getBaseType().isVoid());
        results.forEach(r => {
            if (r.datatype instanceof types.PrimitiveType)
                r.index = fun.addLocal(r.datatype);
            // TODO handle others
        });
        // Last condition must be else clause
        if (conds[conds.length - 1] != '(i32.const 1)') {
            // console.log(conds[conds.length - 1]);
            throw new error.SyntaxError("no else case for fun branch", this.tokens);
        }
        /*
        // n+1 blocks
        let ret = "";
        ret += `(block $branch (result ${retType}) `;
        for (let i = 0; i < conds.length; i++)
            ret += '(block ';

        // add conds
        conds.forEach((c, i) => {
           ret += ` ${c}`;
           ret += ` (br_if ${i})`;
        });

        acts.forEach((a, i) => {
            ret += ')';
            ret += ` ${a}`;
            if (conds.length - i - 1 > 0)
                ret += `(br $branch)`;
        });

        ret += ')';
        return ret;
        */
        // Compile to (if (...) (result ...) (then ...) (else ...))
        // Note that there's some BS done here to work around multi-return if statements not being allowed :(
        const retSet = results.map(r => `(local.set ${r.index})`).join('');
        let ret = (function compileIf(i) {
            return i + 1 >= acts.length
                ? acts[i] + retSet
                : `${conds[i]}\n\t(if ${retType.length === 1 ? `(result ${retType})` : ''}\n\t(then ${acts[i] + retSet})\n\t(else ${compileIf(i + 1)}))`;
        })(0);
        if (retType.length === 1)
            ret += '\n\t' + retSet;
        // console.log('BranchExpr', ret);
        return ret;
    }
    /**
     * @override
     */
    children() {
        return this.conditions.concat(this.actions.reduce((a, v) => a.concat(v)));
    }
}
exports.BranchExpr = BranchExpr;
;
//# sourceMappingURL=branch.js.map