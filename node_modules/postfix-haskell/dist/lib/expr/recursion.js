"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecursiveResultExpr = exports.RecursiveCallExpr = exports.RecFunExpr = exports.RecursiveBodyExpr = exports.RecursiveTakesExpr = void 0;
const expr_1 = require("./expr");
/**
 * Used to wrap arguments passed to recursive functions as they are being tracd in a way that
 * they can later be used to determine the bindings for parameters in
 * recursive calls within the body
 */
class RecursiveTakesExpr extends expr_1.DataExpr {
    /**
     * @param token location in source code
     * @param datatype type of argument
     * @param negIndex stack index of argument
     * @param value value being passed as argument
     */
    constructor(token, datatype, negIndex, value) {
        super(token, datatype);
        this.negIndex = negIndex;
        this.value = value;
    }
    out(ctx, fun) {
        return this.value.out(ctx, fun);
    }
}
exports.RecursiveTakesExpr = RecursiveTakesExpr;
;
/**
 * The body of the inlined, TCO'd recursive function
 * (replaces call that initiates the recursion)
 */
class RecursiveBodyExpr extends expr_1.Expr {
    constructor(token) {
        super(token);
        // Input expressions
        this.takes = null;
        // Input Locals
        this.takeExprs = null;
        // Output expressions
        this.gives = null;
        // Output locals
        this.giveExprs = null;
        this.isTailRecursive = false;
        // Unique labels
        this.id = RecursiveBodyExpr._uid++;
        this.label = `$rec_${this.id}`;
    }
    out(ctx, fun) {
        // Prevent multiple compilations
        this._isCompiled = true;
        // If not tail recursive, generate a helper function instead of a loop
        this.isTailRecursive = this._isTailRecursive();
        if (!this.isTailRecursive)
            return this.outFn(ctx, fun);
        // Select non void types
        const voidTakes = this.takeExprs.map(e => !e.datatype.getBaseType().isVoid() && e);
        const voidGives = this.giveExprs.map(e => !e.datatype.getBaseType().isVoid() && e);
        // Store inputs in locals
        this.takeExprs.forEach(e => {
            e.index = fun.addLocal(e.datatype);
        });
        let ret = `\n\t${this.takeExprs.map((e, i) => `${this.takes[i].out(ctx, fun)}${e.datatype.isVoid() ? '' : `\n\t(local.set ${e.index})`}`).join('\n\t')}\n\t`;
        // Create place to store outputs
        this.giveExprs.forEach(e => {
            e.index = fun.addLocal(e.datatype);
        });
        // Body
        const retType = this.gives.map(e => e.datatype.getWasmTypeName()).join(' ');
        ret += `(loop ${this.label} (result ${retType})\n\t`;
        ret += this.gives.map(e => e.out(ctx, fun)).join('\n\t');
        ret += `)\n\t${this.giveExprs.map(e => e.datatype.isVoid() ? '' : `(local.set ${e.index})`).join(' ')}\n\t`;
        // console.log('RecursiveBodyExpr', ret);
        return ret;
    }
    /**
     * Version of this.out() for when it's not tail-recursive
     */
    outFn(ctx, fun) {
        // Since we're moving body to another function we have to move locals
        const captureExprs = this.gives
            .map(e => e.getLeaves())
            .reduce((a, v) => a.concat(v), [])
            .filter(e => {
            // Parameters need to be passed as arguments to helper
            if (e instanceof expr_1.ParamExpr)
                return true;
            // Should not already be bound, right?
            if ((e instanceof expr_1.DependentLocalExpr && e.index !== -1)
                || (e instanceof expr_1.TeeExpr && e.local !== null)) {
                console.error(e);
                throw new Error("wtf?");
            }
            return false;
        })
            .reverse();
        // Make recursive helper function
        this.helper = new RecFunExpr(this.token, this.label, this.takeExprs, captureExprs);
        this.helper.outputs = this.gives;
        ctx.addFunction(this.helper);
        // Create place to store outputs
        this.giveExprs.forEach(e => {
            e.index = fun.addLocal(e.datatype);
        });
        // Invoke helper function and capture return values into dependent locals
        let ret = `${this.takes.map(e => e.out(ctx, fun)).join('')}${captureExprs.map(e => e.out(ctx, fun)).join('')}\n\t(call ${this.label})${this.giveExprs.map(e => e.datatype.isVoid() ? '' : `(local.set ${e.index})`).join('')}`;
        return ret;
    }
    children() {
        return this.takes
            .concat(this.takeExprs)
            .concat(this.gives)
            .concat(this.giveExprs);
    }
    /**
     * Determine if we can apply tco
     * @returns true if we can use a loop instead of recursive func call
     */
    _isTailRecursive() {
        // Covers infinite loop case
        if (this.gives.some(c => c instanceof RecursiveResultExpr))
            return true;
        function isSameBodyCall(e) {
            return false;
        }
        // If body not a branch result DependentLocalExpr, return false
        // Go through branch conditions, if any of them calls self say no
        // Go through branch actions, if any of them isn't tr, say no
        // istr:
        //  - if it returns RecursiveResultExpr then it's TR
        //  - if it doesn't call self it is tr
        //  - otherwise it's not tr
        // TODO actually detect tail-recursion lol
        return false;
    }
}
exports.RecursiveBodyExpr = RecursiveBodyExpr;
// Used to make unique label
RecursiveBodyExpr._uid = 0;
;
// TODO swap extension order with FunExportExpr
/**
 * Function that gets added to module but isn't exported
 */
class RecFunExpr extends expr_1.FunExportExpr {
    constructor(token, name, takeExprs, copiedParams) {
        // Filter void
        takeExprs = takeExprs.filter(e => !e.datatype.isVoid());
        copiedParams = copiedParams.filter(e => !e.datatype.isVoid());
        super(token, name, takeExprs.map(e => e.datatype).concat(copiedParams.map(p => p.datatype)));
        this.takeExprs = takeExprs;
        this.copiedParams = copiedParams;
    }
    out(ctx) {
        // Capture original positions so that we can revert later so that old references don't break
        const originalIndicies = this.copiedParams.map(e => e.position);
        // Alias our DependentLocalExpr inputs to params
        this.takeExprs.forEach((e, i) => {
            e.index = i;
        });
        // Temporarily update indicies to refer to our params
        this.copiedParams.forEach((e, i) => {
            e.position = this.takeExprs.length + i;
        });
        // Compile body & generate type signatures
        // TODO tuples
        const outs = this.outputs.map(o => o.out(ctx, this));
        const paramTypes = this.inputTypes.map(t => t.getWasmTypeName()).filter(Boolean).join(' ');
        const resultTypes = this.outputs.map(r => r.datatype.getWasmTypeName()).filter(Boolean).join(' ');
        // Generate output wat
        const ret = `(func ${this.name} ${
        // Parameter types
        paramTypes ? `(param ${paramTypes})` : ''} ${
        // Return types
        resultTypes ? `(result ${resultTypes})` : ''}\n\t\t${
        // Local variables
        this._locals.filter(Boolean).map(l => `(local ${l.getWasmTypeName()})`).join(' ')}\n\t${
        // Write body
        outs.join('\n\t')})`;
        // Revert modifications to the exprs so that other places they're referenced don't break
        this.copiedParams.forEach((e, i) => {
            e.position = originalIndicies[i];
        });
        return ret;
    }
}
exports.RecFunExpr = RecFunExpr;
;
/**
 * Recursive calls within function body
 */
class RecursiveCallExpr extends expr_1.Expr {
    constructor(token, body, takeExprs) {
        super(token);
        this.takeExprs = takeExprs;
        this.body = body;
        // Here we can use ResultExpr's because using it violates tail-recursion
        //  thus we don't have to worry about them getting out of order
        this.giveExprs = body.giveExprs.map((e, i) => new RecursiveResultExpr(token, e.datatype, this, i));
    }
    out(ctx, fun) {
        // TCO behavior
        if (this.body.isTailRecursive) {
            // console.log('call', this.giveExprs);
            // Set arg locals
            let ret = `\n\t${this.takeExprs.map((e, i) => `${e.out(ctx, fun)}${(!this.body.takeExprs[i] || e.datatype.getBaseType().isVoid())
                ? '' : `\n\t(local.set ${this.body.takeExprs[i].index})`}`).join('\n\t')}\n\t`;
            // Invoke function
            ret += `(br ${this.body.label})`;
            // console.log('RecursiveCallExpr', ret);
            return ret;
        }
        if (fun !== this.body.helper)
            throw new Error('wtf?');
        // Call helper function
        // Note this will always be in the body of the helper function and thus a recursive call
        return `\n\t${this.takeExprs.map((e, i) => e.out(ctx, fun)).join(' ')} ${this.body.helper.copiedParams.map(p => p.out(ctx, fun)).join('')} (call ${this.body.label})`;
    }
    children() {
        return this.body.children().concat(this.takeExprs).concat(this.giveExprs);
    }
}
exports.RecursiveCallExpr = RecursiveCallExpr;
// Shouldn't matter because result shouldn't get used
RecursiveCallExpr.expensive = true;
;
/**
 * Unused Result of an expression that can have multiple return values
 */
class RecursiveResultExpr extends expr_1.DataExpr {
    /**
     * @param token - Locaation in code
     * @param datatype - Datatype for expr
     * @param source - Origin expression
     * @param position - Stack index (0 == left)
     */
    constructor(token, datatype, source, position) {
        super(token, datatype);
        this.source = source;
        this.position = position;
    }
    out(ctx, fun) {
        let ret = '';
        if (!this.source._isCompiled)
            ret += this.source.out(ctx, fun);
        // When tail-recursive we don't care about intermediate results
        if (this.source.body.isTailRecursive)
            return ret;
        return ret;
    }
    children() {
        return [this.source];
    }
}
exports.RecursiveResultExpr = RecursiveResultExpr;
;
//# sourceMappingURL=recursion.js.map