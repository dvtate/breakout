"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiInstrExpr = exports.fromDataValue = exports.TeeExpr = exports.InstrExpr = exports.NumberExpr = exports.ParamExpr = exports.FunExportExpr = exports.DependentLocalExpr = exports.DataExpr = exports.Expr = void 0;
const value = require("../value");
const error = require("../error");
/**
 * This stores expressions that we can reason about
 * but can't completly eliminate from the code.
 *
 * For example, operations on user input and not constant-values
 *
 * @abstract
 * @class
 */
class Expr extends value.Value {
    /**
     * @constructor
     * @param token - Source location
     */
    constructor(token) {
        super(token, value.ValueType.Expr, undefined);
        // State variable to prevent duplicated compilation
        this._isCompiled = false;
    }
    /**
     * Compilation action
     * @virtual
     * @param fun - function export context
     * @returns - wasm translation
     */
    out(ctx, fun) {
        return '';
    }
    /**
     * Get all expressions which constitute this one
     * @returns child nodes
     * @virtual
     */
    children() {
        return [];
    }
    /**
     * Exhaustive version of .children()
     * @returns all child nodes which don't have children
     */
    getLeaves() {
        let ret = new Set(this.children());
        let retLen = ret.size;
        do {
            retLen = ret.size;
            // console.log('v', retLen, [...ret][2]);
            ret = [...ret]
                .map(e => {
                const ret = e.children();
                // ts-ignore
                if (ret.some(e => !e.children)) {
                    console.log('no cs', e);
                }
                return ret.length === 0 ? e : ret;
            }).reduce((a, v) => {
                if (v instanceof Array) {
                    v.forEach(e => a.add(e));
                }
                else {
                    a.add(v);
                }
                return a;
            }, new Set());
        } while (retLen != ret.size);
        return [...ret];
    }
}
exports.Expr = Expr;
/**
 * Would it be better to store the value in a local or inline it multiple times?
 * @virtual
 */
Expr.expensive = true;
;
/**
 * Data Expressions
 * @abstract
 * @class
 */
class DataExpr extends Expr {
    /**
     * @param token - location in code
     * @param datatype - Datatype for value
     */
    constructor(token, datatype) {
        super(token);
        this.datatype = datatype;
    }
}
exports.DataExpr = DataExpr;
DataExpr.expensive = false;
;
/**
 * For when the output of an expression is stored in a local variable
 *
 * used to handle multi-returns so that they don't get used out of order
 */
class DependentLocalExpr extends DataExpr {
    constructor(token, datatype, source) {
        super(token, datatype);
        this.source = source;
        this.index = -1;
    }
    out(ctx, fun) {
        // source.out() will update our index to be valid
        return `${!this.source._isCompiled ? this.source.out(ctx, fun) : ''} ${this.datatype.getBaseType().isVoid() ? '' : `(local.get ${this.index})`}`;
    }
    children() {
        return this.source.children();
    }
}
exports.DependentLocalExpr = DependentLocalExpr;
;
/**
 * Function Export expression
 */
class FunExportExpr extends Expr {
    /**
     * @param token - Source location
     * @param name - Export label
     * @param inputTypes - Types for input values
     * @param outputs - Generated exprs for return values
     */
    constructor(token, name, inputTypes) {
        super(token);
        // Output expressions
        this.outputs = [];
        this.name = name;
        this.inputTypes = inputTypes.filter(t => !t.getBaseType().isVoid());
        this._locals = inputTypes.filter(t => !t.getBaseType().isVoid()).map(t => null);
    }
    /**
     * @param type - storage type for local
     * @returns - local index
     */
    addLocal(type /*types.PrimitiveType*/) {
        // Don't add locals for void types
        if (type.isVoid())
            return -1;
        // TODO when given non-primitive type expand it to a list of primitives
        // new return type will be array
        return this._locals.push(type) - 1;
    }
    /**
     * Reserve space for value
     * @param type storage type for local
     * @param token source location
     * @returns local indicies
     */
    addLocals(type, token) {
        try {
            return type.flatPrimitiveList().map(this.addLocal);
        }
        catch (e) {
            throw e === 'union'
                ? new error.SyntaxError('Invalid union type', token)
                : e;
        }
    }
    // TODO should make apis to help lift nested functions/closures
    out(ctx) {
        // TODO tuples
        const outs = this.outputs.map(o => o.out(ctx, this));
        const paramTypes = this.inputTypes.map(t => t.getWasmTypeName()).filter(Boolean).join(' ');
        const resultTypes = this.outputs.map(r => r.datatype.getWasmTypeName()).filter(Boolean).join(' ');
        return `(func $${this.name} ${paramTypes ? `(param ${paramTypes})` : ''} ${resultTypes ? `(result ${resultTypes})` : ''}\n\t\t${this._locals.filter(Boolean).map(l => `(local ${l.getWasmTypeName()})`).join(' ')}\n\t${outs.join('\n\t')})\n(export "${this.name}" (func $${this.name}))`;
    }
}
exports.FunExportExpr = FunExportExpr;
;
/**
 * Function parameters expression
 */
class ParamExpr extends DataExpr {
    /**
     * @param token - Locaation in code
     * @param datatype - Datatype for expr
     * @param source - Origin expression
     * @param position - Stack index (0 == left)
     */
    constructor(token, datatype, source, position) {
        super(token, datatype);
        this.source = source;
        this.position = position;
    }
    out(ctx, fun) {
        if (this.datatype.getBaseType().isVoid())
            return '';
        return `(local.get ${this.position})`;
    }
}
exports.ParamExpr = ParamExpr;
;
/**
 * Constant value that we're treating as an Expr
 */
class NumberExpr extends DataExpr {
    /**
     * @param token - Location in code
     * @param value - Value to wrap
     */
    constructor(token, value) {
        super(token, value.datatype);
        this.value = value;
    }
    /**
     * @override
     */
    out(ctx, fun) {
        const outValue = (v) => v instanceof value.TupleValue
            ? v.value.map(outValue).join()
            : v.value.toWAST();
        return outValue(this.value);
    }
    children() {
        return [];
    }
}
exports.NumberExpr = NumberExpr;
;
/**
 * Passes stack arguments to desired WASM instruction
 */
class InstrExpr extends DataExpr {
    constructor(token, datatype, instr, args) {
        super(token, datatype);
        this.instr = instr;
        this.args = args;
    }
    /**
     * @override
     */
    out(ctx, fun) {
        return `(${this.instr} ${this.args.map(e => e.out(ctx, fun)).join(' ')})`;
    }
    children() {
        return this.args;
    }
}
exports.InstrExpr = InstrExpr;
InstrExpr.expensive = true;
;
/**
 * Used for repeated expressions
 * Normally we'd try to use something like dup but wasm weird
 * First time it's compiled it stores value in a new local
 * After that it just does local.get
 */
class TeeExpr extends DataExpr {
    /**
     * @param token - origin in source code
     * @param expr - value to store in a local so that we can copy it
     */
    constructor(token, expr) {
        super(token, expr.datatype);
        this.local = null;
        this.value = expr;
    }
    /**
     * @override
     */
    out(ctx, fun) {
        return this.value.out(ctx, fun);
        if (this.local === null) {
            this.local = fun.addLocal(this.datatype);
            return `${this.value.out(ctx, fun)}\n\t${this.datatype.getBaseType().isVoid() ? '' : `(local.tee ${this.local})`}`;
        }
        return this.datatype.getBaseType().isVoid() ? '' : `(local.get ${this.local})`;
    }
}
exports.TeeExpr = TeeExpr;
// Prevent this from getting re-tee'd
TeeExpr.expensive = false;
;
/**
 * Flatten a list of mixed values+expressions into a single list of expressions
 * @param vs array of values
 * @returns array of expressions
 */
function fromDataValue(vs) {
    return vs.map(v => {
        if (v instanceof DataExpr)
            return v;
        if (v instanceof value.NumberValue)
            return new NumberExpr(v.token, v);
        if (v instanceof value.TupleValue)
            return fromDataValue(v.value);
        // Eww runtime error...
        throw new error.TypeError("incompatible type", v.token, v, null);
    }).reduce((a, v) => v instanceof Array ? a.concat(v) : (a.push(v), a), []);
}
exports.fromDataValue = fromDataValue;
/**
 * Similar to InstrExpr but with multi-returns captured into dependent locals
 * ... probably not needed
 * @deprecated
 */
class MultiInstrExpr extends Expr {
    constructor(token, instr, args, resultTypes) {
        super(token);
        this.instr = instr;
        this.args = args;
        this.results = resultTypes.map(t => new DependentLocalExpr(token, t, this));
    }
    /**
     * @override
     */
    out(ctx, fun) {
        //
        this.results.forEach(e => {
            if (!e.datatype.isVoid())
                e.index = fun.addLocal(e.datatype);
        });
        const inds = this.results.map(e => e.index).filter(i => i !== -1);
        return `(${this.instr} ${this.args.map(e => e.out(ctx, fun)).join(' ')})\n${inds.map(i => `(local.set ${i})`)}`;
    }
    children() {
        return this.args;
    }
}
exports.MultiInstrExpr = MultiInstrExpr;
MultiInstrExpr.expensive = true;
;
//# sourceMappingURL=expr.js.map