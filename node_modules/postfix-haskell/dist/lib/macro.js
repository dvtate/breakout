"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMacro = exports.LiteralMacro = exports.CompilerMacro = exports.Macro = void 0;
const context_1 = require("./context");
const parse_1 = require("./parse");
const value = require("./value");
/**
 * Macros are similar to blocks of code, or executable arrays in postscript
 * @abstract
 */
class Macro {
    constructor() {
        /**
         * Did the user flag this macro as recursive?
         */
        this.recursive = false;
    }
    /**
     * Invoke macro
     * @virtual
     * @param ctx - Context object
     * @param token - token of invokee
     * @returns - Macro return
     */
    action(ctx, token) { }
}
exports.Macro = Macro;
/**
 * A macro that is created internally by the compiler
 */
class CompilerMacro extends Macro {
    /**
     * @param invokeAction - body of the macro
     */
    constructor(invokeAction, name) {
        super();
        this.invokeAction = invokeAction;
        this.name = name;
    }
    /**
     * @override
     */
    action(ctx, token) {
        return this.invokeAction(ctx, token);
    }
    // TODO toString for debugging
    toString() {
        return `CompilerMacro { ${this.name} }`;
    }
}
exports.CompilerMacro = CompilerMacro;
;
/**
 * User-defined macros only
 */
class LiteralMacro extends Macro {
    /**
     * Construct Macro object from literal token
     * @param ctx - context for literal
     * @param token - token for literal
     */
    constructor(ctx, token) {
        super();
        this.token = token;
        this.body = token.body;
        this.scopes = ctx.scopes.slice();
    }
    /**
     * @override
     */
    action(ctx, token) {
        // TODO simplify and/or use ctx.copyState()
        // Use proper lexical scope
        const oldScopes = ctx.scopes;
        ctx.scopes = this.scopes;
        ctx.scopes.push({});
        // Invoke body
        let ret;
        try {
            ret = (0, parse_1.default)(this.body, ctx);
        }
        catch (e) {
            // Always Restore ctx state
            ctx.scopes.pop();
            ctx.scopes = oldScopes;
            throw e;
        }
        // Restore ctx state
        ctx.scopes.pop();
        ctx.scopes = oldScopes;
        return ret;
    }
    /**
     * Handle namespace call
     * @param ctx - context object
     * @param token - invokee token
     * @returns - on success return namespace accessor macro on otherwise returns error
     */
    getNamespace(ctx, token) {
        // TODO simplify and/or use ctx.copyState()
        // Use proper lexical scope
        const oldScopes = ctx.scopes;
        ctx.scopes = this.scopes;
        ctx.scopes.push({});
        // Invoke body
        let ret;
        try {
            ret = ctx.toError((0, parse_1.default)(this.body, ctx), token);
        }
        catch (e) {
            // Always Restore ctx state
            ctx.scopes.pop();
            ctx.scopes = oldScopes;
            throw e;
        }
        // Restore ctx state
        const newScope = ctx.scopes.pop();
        ctx.scopes = oldScopes;
        // On successs return the scope otherwise give the error
        return ret instanceof context_1.default
            ? new value.MacroValue(token, new NamespaceMacro(newScope, token))
            : ret;
    }
    toString() {
        return `LiteralMacro { ${this.token.file || this.token.position} }`;
    }
}
exports.LiteralMacro = LiteralMacro;
;
/**
 * Macro Value that when given an id returns corresponding id in namespace
 */
class NamespaceMacro extends Macro {
    constructor(scope, token) {
        super();
        this.scope = scope;
        this.token = token;
    }
    /**
     * Given an identifier assign to it this.scope
     * @override
     */
    action(ctx, token) {
        // Assign the scope to the given identifier
        const id = ctx.pop();
        if (!(id instanceof value.IdValue))
            return ['expected an identifier'];
        id.scopes = [this.scope];
        ctx.push(id);
    }
    /**
     * Promote [some] identifiers to the current scope
     * @param ctx context objecr
     * @param token invokee site
     * @param include regex for identifiers to include
     * @param exclude regex for identifiers to exclude
     */
    promote(ctx, token, include, exclude) {
        // Figure out what to promote
        let toPromote = Object.entries(this.scope);
        if (include !== undefined) {
            const inclRxp = new RegExp(`^${include}$`);
            const exclRxp = new RegExp(`^${exclude}$`);
            toPromote = toPromote
                .filter(([id]) => id.match(inclRxp))
                .filter(([id]) => !id.match(exclRxp));
        }
        // Warn nothing promoted
        if (toPromote.length === 0) {
            ctx.warn(token, 'nothing to promote');
            console.warn({ include, exclude, toPromote, obj: this });
            return;
        }
        // Promote each into an unqualified id
        const curScope = ctx.scopes[ctx.scopes.length - 1];
        toPromote.forEach(([id, v]) => {
            // Warn on overwrite
            if (curScope[id] && curScope[id] != v)
                ctx.warn(token, `Overwrote identifier $${id}`);
            // Write to current scope
            curScope[id] = v;
        });
    }
}
exports.NamespaceMacro = NamespaceMacro;
;
//# sourceMappingURL=macro.js.map