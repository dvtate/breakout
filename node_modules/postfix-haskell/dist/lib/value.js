"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StrValue = exports.TupleValue = exports.IdValue = exports.NumberValue = exports.MacroValue = exports.DataValue = exports.Value = exports.ValueType = void 0;
const types = require("./datatypes");
const numbers_1 = require("./numbers");
/*
 * In this context, Values are like nodes on an AST, but also used to simplify constexprs/partial evaluation
 */
/**
 * Enum to represent what syntactic type is currently on the stack
 */
// TODO should probably use Classes/Inheritance instead of this
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Macro"] = 0] = "Macro";
    ValueType[ValueType["Data"] = 1] = "Data";
    ValueType[ValueType["Type"] = 2] = "Type";
    ValueType[ValueType["Id"] = 3] = "Id";
    ValueType[ValueType["Expr"] = 4] = "Expr";
    ValueType[ValueType["Fxn"] = 5] = "Fxn";
    ValueType[ValueType["Str"] = 6] = "Str";
    // TODO make tuples a distinct ValueType
})(ValueType = exports.ValueType || (exports.ValueType = {}));
;
// TODO should be abstract
/**
 * Generic value base class
 */
class Value {
    constructor(token, type, value, datatype) {
        this.token = token;
        this.type = type;
        this.value = value;
        this.datatype = datatype;
    }
    /**
     * Do we know it at compile time?
     */
    isConstExpr() {
        return this.type !== ValueType.Expr;
    }
    /**
     * Name for type of this value
     */
    typename() {
        return ValueType[this.type];
    }
}
exports.Value = Value;
;
/**
 * Data with a user-level type, this includes unions, structs and aliases
 */
class DataValue extends Value {
    constructor(token, type, value) {
        super(token, ValueType.Data, value, type);
        this.type = ValueType.Data;
    }
}
exports.DataValue = DataValue;
;
/**
 * Invokable block of code
 */
class MacroValue extends Value {
    constructor(token, value, type = null) {
        super(token, ValueType.Macro, value, type);
        this.datatype = null;
        this.type = ValueType.Macro;
    }
}
exports.MacroValue = MacroValue;
;
/**
 * Primitive data, native wasm types
 */
class NumberValue extends DataValue {
    constructor(token, wasmNumber) {
        super(token, NumberValue._typeMap[wasmNumber.type], wasmNumber);
    }
    /**
     * See code in expr/expr.ts
     */
    out() {
        return this.value.toWAST();
    }
    /**
     * See code in expr/expr.ts
     */
    children() {
        return [];
    }
}
exports.NumberValue = NumberValue;
// Map of number types to coresponding primitive datatypes
NumberValue._typeMap = Object.keys(numbers_1.default.Type)
    .filter(k => isNaN(parseFloat(k))) // Only the labels because ts does both
    .reduce((acc, v) => ({
    ...acc,
    [numbers_1.default.Type[v]]: types.PrimitiveType.Types[v],
}), {});
;
/**
 * Escaped Identifier
 */
class IdValue extends Value {
    constructor(token, id, scopes) {
        super(token, ValueType.Id, id);
        this.scopes = scopes;
    }
    /**
     * Convert Id's to values
     */
    deref(ctx) {
        return ctx.getId(this.value.slice(1), this.scopes || ctx.scopes);
    }
}
exports.IdValue = IdValue;
;
/**
 * Packed values
 */
class TupleValue extends DataValue {
    constructor(token, values, datatype) {
        const type = datatype || new types.TupleType(token, values.map(v => v.datatype || null));
        super(token, type, values);
    }
    out(ctx, fun) {
        return this.value.map(v => v.out(ctx, fun)).join('');
    }
}
exports.TupleValue = TupleValue;
;
// Note that there is no need for a UnionValue class because there are no instances of unions
// unions will only be needed as types for opaque?-expressions
/**
 * String literal, not data
 */
class StrValue extends Value {
    constructor(token) {
        super(token, ValueType.Str, token.token);
    }
}
exports.StrValue = StrValue;
;
//# sourceMappingURL=value.js.map