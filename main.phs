"../postfix-haskell/planning/stdlib/prelude.phs" include use
"../postfix-haskell/planning/stdlib/io.phs" include use
"../postfix-haskell/planning/stdlib/monad.phs" include use
"../postfix-haskell/planning/stdlib/str.phs" include use
"../postfix-haskell/planning/stdlib/math.phs" include use
"../postfix-haskell/planning/stdlib/bits.phs" include use

# Cucked game monad
Void class $Game =

# Game dimensions
400 $width =
500 $height =

# the wall width takes up the remaining space of the canvas width. with 14 bricks
# and 13 2px gaps between them, thats: 400 - (14 * 25 + 2 * 13) = 24px. so each
# wall will be 12px
#12 $wallSize =

{ # Detect collision between 2 rectangles
    {   $x1 $y1 $w1 $h1
        $x2 $y2 $w2 $h2 } =
    x1 x2 w2 + <
    x1 w1 + x2 > &&
    y1 y2 h2 + < &&
    y1 h1 + y2 > &&
} $rect_collide =

##
# Paddle: position, speed
##

{ I32 I32 } pack class $Paddle =

# TODO momentum based controls
1 $Paddle.Speed =
440 $Paddle.Y =

{ type Paddle == } { unpack pop } $Paddle.position fun
{ type Paddle == } { unpack swap pop } $Paddle.speed fun
{ type Paddle == } {
    $paddle =
    { true } { paddle Paddle.position } $branch fun
    { paddle unpack { $p $s } =
        s 0 >   p width Brick.Width - < &&
        s 0 <   p 0 >                   &&  ||
    } {
        paddle unpack +
    } $branch fun
    { branch paddle Paddle.speed } pack Paddle make
} $Paddle.update fun

##
# Ball
##
{ I32 I32 I32 I32 } pack class $Ball =
10 $Ball.Width =
10 $Ball.Height =

# Getters
{ type Ball == } { unpack { $x $y $dx $dy } = x  } $Ball.x fun
{ type Ball == } { unpack { $x $y $dx $dy } = y  } $Ball.y fun
{ type Ball == } { unpack { $x $y $dx $dy } = dx } $Ball.dx fun
{ type Ball == } { unpack { $x $y $dx $dy } = dy } $Ball.dy fun
{ { $paddle $ball } =
    paddle type Paddle == ball type Ball == &&
} {
    # Aliasing
    { $paddle $ball } =
    ball unpack { $x $y $dx $dy } =
    paddle Paddle.position $pp =

    # No collisions
    { true } { y dx dy } $branch fun

    # Detect collision with paddle
    {   # pp Paddle.Y Brick.Width Brick.Height
        # x y Ball.Width Ball.Height
        # rect_collide
        false
    } {
        # Note ball placed above paddle
        Paddle.Y Ball.Height - dx 0 dy -
    } $branch fun

    # Detect collision with walls
    { x dx + 0 <= } { y 0 dx - dy } $branch fun
    { x dx + width >= } { y 0 dx - dy } $branch fun
    { y dy + 0 <= } { y dx 0 dy - } $branch fun
    branch

    # Move ball
    { $y1 $dx1 $dy1 } =
    paddle
    { x dx1 + y1 dy1 + dx1 dy1 } pack Ball make
} $Ball.update fun


{ { $x $y $h $w $color } =
    # Set fill
    color 0xff0000 and 16 >> $r =
    color 0xff00 and 8 >> $g =
    color 0xff and $b =
    r g b { Game I32 I32 I32 } { Game } Arrow { "js" "setFill" } import @

    # Draw rectangle
    x y w h { Game I32 I32 I32 I32 } { Game } Arrow { "js" "contextFillRect" } import @
} $Game.draw_rect =

2 $Brick.Gap =
25 $Brick.Width =
12 $Brick.Height =

# 24 bit colors
0x0 $Colors.Gone =
0xff0000 $Colors.Red =
0x00ff00 $Colors.Green =
0x0000ff $Colors.Blue =
0x00ffff $Colors.Cyan =
0xffffff $Colors.White =

{
    { $ball $paddle } =
    # Clear scene
    0 0 width height
    { Game I32 I32 I32 I32 } { Game } Arrow
    { "js" "contextClearRect" } import @

    # Draw paddle
    paddle Paddle.position
    Paddle.Y
    Brick.Height
    Brick.Width
    Colors.White
    Game.draw_rect

    # Draw ball
    ball Ball.x
    ball Ball.y
    Ball.Width
    Ball.Height
    Colors.White
    Game.draw_rect

    #0 0 100 200 Colors.White Game.draw_rect

    ball paddle
} $Game.draw =

{
    Paddle.update
    swap Ball.update swap
} $Game.update =

# So sketchy lol
{ # Load state from memory
    { 4 * { I32 } { I32 } Arrow "i32.load" _asm } $load_i32 =
    { 0 load_i32 1 load_i32 2 load_i32 3 load_i32 } pack Ball make
    { 4 load_i32 5 load_i32 } pack Paddle make
} $Game.get_state =

{ # Save state to memory
    { swap 4 * swap { Game I32 I32 } { Game } Arrow "i32.store" _asm } $store_i32 =
    { $ball $paddle } =
    0 ball Ball.x store_i32
    1 ball Ball.y store_i32
    2 ball Ball.dx store_i32
    3 ball Ball.dy store_i32
    4 paddle Paddle.position store_i32
    5 paddle Paddle.speed store_i32
} $Game.set_state =

{ # Main loop
    Game.get_state
    Game.update
    Game.draw
    Game.set_state

    # Await next frame
    { Game } { Game } Arrow { "js" "nextFrame" } import @
} $Game.loop =

{
    { 300 width 2 / 1 1 } pack Ball make
    { width 2 / Brick.Width 2 / - 0 } pack Paddle make
    Game.set_state
} $Game.init =

{ Game } {
    Game.loop
} $loop export
{ Game } { Game.init } $init export
{ Game } {
    Game.get_state
    Game.update
    Game.set_state
} $update export

{Game} {
    Game.get_state
    Game.draw
    pop pop
} $draw export

{ Game } { # Stop moving the paddle
    Game.get_state
    $paddle =
    { paddle unpack pop 0 } pack Paddle make
    Game.set_state
} $arrow_up export

{ Game } {} $space_down export

{ Game } {
    Game.get_state
    $paddle =
    { paddle unpack pop Paddle.Speed } pack Paddle make
    Game.set_state
} $arrow_right_down export

{ Game } {
    Game.get_state
    $paddle =
    { paddle unpack pop 0 Paddle.Speed - } pack Paddle make
    Game.set_state
} $arrow_left_down export
